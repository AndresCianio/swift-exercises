
# 18. Error Handling

## Constants and Variables

### Exercise TEMPLATE

Placeholder text.

<details>
<summary>Solution</summary>
```Swift

```
</details>

### Exercise 18.1

Define a basic error enumeration type called RuntimeError that you can throw and catch in the following exercises.   
The error should be capable of representing a message describing the problem that has occured. 
<details>
<summary>Solution</summary>
```Swift
enum RuntimeError : Error
{
    case genericError(String)
}
```
</details>


### Exercise 18.2

Write a function called parseInt that takes an input string and converts it to an integer value that it returns. If the string cannot be converted to an integer the function should throw the RuntimeError defined above.
<details>
<summary>Solution</summary>
```Swift
func parseInt(text : String!) throws -> Int {
    if let result = Int(text) {
        return result
    } else {
        throw RuntimeError.genericError("Could not convert the string '\(text!)' to an Int")
    }
}
```
</details>

### Exercise 18.3

Call the parseInt function with the parameters "1337" and "leet" assigning the result to variables named a and b respectively. If parseInt fails set the variable to nil.
<details>
<summary>Solution</summary>
```Swift
let a = try? parseInt(text:"1337")
let b = try? parseInt(text:"leet")
```
</details>

### Exercise 18.3

Call the parseInt function with the parameters "1337" and "leet" assigning the result to variables named a and b respectively. If parseInt fails print the reason it failed.
<details>
<summary>Solution</summary>
```Swift
do {

    let a = try parseInt(text:"1337")
    let b = try parseInt(text:"leet")
    
} catch RuntimeError.genericError(let message)  {
    print(message)
}

```
</details>

### Exercise 18.4

Write a function called addStrings that takes two strings as parameters and returns their sum as an Int. If any of the parameters are incorrect an error should be thrown.
<details>
<summary>Solution</summary>
```Swift
func addStrings(a:String!, b:String!) throws -> Int {
    return try parseInt(text: a) + parseInt(text: b)
}

try? addStrings(a:"17",b:"4711")
try? addStrings(a:"17",b:"leet")
```
</details>

### Exercise 18.5

Consider what the equivalent code to the above would have looked like in Objective-C.
<details>
<summary>Solution</summary>
```Objective-C

// NSNumber is used so that nil can represent failure.

NSNumber * ParseInt(NSString * a, NSError **error) {
  NSParameterAssert(a != nil);
  NSScanner * scanner = [NSScanner scannerWithString:a];
  NSInteger integer = 0;
  BOOL success = [scanner scanInteger:&integer];
  if (!success) {
    if (error != nil) {
      *error = [NSError errorWithDomain:@"RuntimeError" code:0 description:@"Could not convert string to integer."];
    }
    return nil;
  }
  
  return [NSNumber numberWithInteger:integer];  
}

NSNumber * AddStrings(NSString * a, NSString * b, NSError **error) {
  NSParameterAssert(a != nil);
  NSParameterAssert(b != nil);
  
  NSNumber * an = ParseInt(a,error);
  if (an == nil) {
    return nil;
  }
  NSNumber * bn = ParseInt(b,error);
  if (bn == nil) {
    return nil;
  }
  
  NSNumber * result = [NSNumber numberWithInteger:an.integerValue + bn.integerValue];
  return result;  
}

// do-catch equivalent
NSError * error = nil;
NSNumber * sum = AddStrings("17","4711",&error);
if (sum == nil) {
  NSLog(@"Error %@", error);
}

// try? equivalent
NSNumber * sum = AddStrings("17","4711",nil);
```
</details>

