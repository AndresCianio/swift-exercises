
# 18. Error Handling

## Constants and Variables

### Exercise TEMPLATE

Placeholder text.

<details>
<summary>Solution</summary>
```Swift

```
</details>

### Exercise 18.1

Define a basic error enumeration type called RuntimeError that you can throw and catch in the following exercises.   
The error should be capable of representing a message describing the problem that has occured. 
<details>
<summary>Solution</summary>
```Swift
enum RuntimeError : Error
{
    case genericError(String)
}
```
</details>


### Exercise 18.2

Write a function called parseInt that takes an input string and converts it to an integer value that it returns. If the string cannot be converted to an integer the function should throw the RuntimeError defined above.
<details>
<summary>Solution</summary>
```Swift
func parseInt(text : String!) throws -> Int {
    if let result = Int(text) {
        return result
    } else {
        throw RuntimeError.genericError("Could not convert the string '\(text!)' to an Int")
    }
}
```
</details>

### Exercise 18.3

Call the parseInt function with the parameters "1337" and "leet" assigning the result to variables named a and b respectively. If parseInt fails set the variable to nil.
<details>
<summary>Solution</summary>
```Swift
let a = try? parseInt(text:"1337")
let b = try? parseInt(text:"leet")
```
</details>

### Exercise 18.3

Call the parseInt function with the parameters "1337" and "leet" assigning the result to variables named a and b respectively. If parseInt fails print the reason it failed.
<details>
<summary>Solution</summary>
```Swift
do {

    let a = try parseInt(text:"1337")
    let b = try parseInt(text:"leet")
    
} catch RuntimeError.genericError(let message)  {
    print(message)
}

```
</details>

### Exercise 18.4

Write a function called addStrings that takes two strings as parameters and returns their sum as an Int. If any of the parameters are incorrect an error should be thrown.
<details>
<summary>Solution</summary>
```Swift
func addStrings(a:String!, b:String!) throws -> Int {
    return try parseInt(text: a) + parseInt(text: b)
}

try? addStrings(a:"17",b:"4711")
try? addStrings(a:"17",b:"leet")
```
</details>

### Exercise 18.5

Consider what the equivalent code to the above would have looked like in Objective-C.
<details>
<summary>Solution</summary>
```Objective-C

// NSNumber is used so that nil can represent failure.

NSNumber * ParseInt(NSString * a, NSError **error) {
  NSParameterAssert(a != nil);
  NSScanner * scanner = [NSScanner scannerWithString:a];
  NSInteger integer = 0;
  BOOL success = [scanner scanInteger:&integer];
  if (!success) {
    if (error != nil) {
      *error = [NSError errorWithDomain:@"RuntimeError" code:0 description:@"Could not convert string to integer."];
    }
    return nil;
  }
  
  return [NSNumber numberWithInteger:integer];  
}

NSNumber * AddStrings(NSString * a, NSString * b, NSError **error) {
  NSParameterAssert(a != nil);
  NSParameterAssert(b != nil);
  
  NSNumber * an = ParseInt(a,error);
  if (an == nil) {
    return nil;
  }
  NSNumber * bn = ParseInt(b,error);
  if (bn == nil) {
    return nil;
  }
  
  NSNumber * result = [NSNumber numberWithInteger:an.integerValue + bn.integerValue];
  return result;  
}

// do-catch equivalent
NSError * error = nil;
NSNumber * sum = AddStrings("17","4711",&error);
if (sum == nil) {
  NSLog(@"Error %@", error);
}

// try? equivalent
NSNumber * sum = AddStrings("17","4711",nil);
```
</details>

func splitAndApply(list:[String], closure:((String,String) throws->Int)) rethrows -> Int
{
    var result = 0
    for x in list {
        let split = x.components(separatedBy: " ")
        if (split.count == 2) {
            result += try closure(split[0],split[1])
        }
    }
    
    return result
}

### Exercise 18.6

Write a function called splitAndApply that takes an array of Strings and a closure as parameters. The closure should take two String parameters and return an Int.

The split and apply function should attempt to split each string in the array it is passed on space characters and if a string is
split into exactly two part call the closure with those parts. 

The splitAndApply function should return the sum of the output of calle to the closure.

Pass the below array to the function and pass the addStrings function as the closure parameter.

let items = ["Orange", "1 1", "4711", "2 8"]

<details>
<summary>Solution</summary>
```Swift
func splitAndApply(list:[String], closure:((String,String) throws->Int)) rethrows -> Int
{
    var result = 0
    for x in list {
        let split = x.components(separatedBy: " ")
        if (split.count == 2) {
            result += try closure(split[0],split[1])
        }
    }
    
    return result
}

let items = ["Orange", "1 1", "4711", "2 8"]
let result = try splitAndApply(list: items, closure: addStrings) // The result should be 12

```
</details>



